<!DOCTYPE html>
<html lang="fr">
<head>
    <link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml" />    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RC Master Pro v12.8 ‚Äî Calculateur de Circuit RC S√©rie & Diagrammes de Fresnel (vectoriels)</title>
    <meta name="description" content="Outil professionnel gratuit pour r√©soudre les circuits RL en s√©rie. Calculez l'imp√©dance, le d√©phasage, les puissances et visualisez les diagrammes de Fresnel et l'oscilloscope en temps r√©el.">
    <meta name="keywords" content="circuit RL, √©lectricit√©, imp√©dance, Fresnel, oscilloscope, g√©nie √©lectrique, calcul d√©phasage, puissance active r√©active">
    <meta name="author" content="OM 2026">
    <meta name="robots" content="index, follow">    <link rel="icon" type="png" href="16BB.svg">
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$']]
            },
            options: {
                enableMenu: false
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                }
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        :root {
            --bg: #0f172a; --card: #1e293b; --accent: #38bdf8;
            --text: #f1f5f9; --muted: #94a3b8; --success: #22c55e;
            --warn: #f43f5e; --induct: #f59e0b; --current: #f472b6;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); padding: 15px; line-height: 1.4; }
        .container { max-width: 1200px; margin: 0 auto; }
        
        header { 
            display: flex; align-items: center; justify-content: space-between;
            background: var(--card); padding: 15px 20px; border-radius: 12px; 
            border: 1px solid #334155; margin-bottom: 20px;
        }

        .actions { display: flex; gap: 10px; margin-bottom: 20px; }
        button { 
            flex: 1; padding: 12px; border-radius: 8px; border: none; 
            cursor: pointer; font-weight: 700; transition: 0.3s; 
            text-transform: uppercase;
        }
        .btn-gen { background: var(--accent); color: #0f172a; }
        .btn-solve { background: var(--success); color: #0f172a; }
        button:hover { opacity: 0.9; transform: translateY(-1px); }

        .grid { 
            display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); 
            gap: 12px; margin-bottom: 25px; 
        }
        .input-group { 
            background: var(--card); padding: 10px 14px; border-radius: 10px; 
            border: 1px solid #334155; position: relative;
        }
        .input-group.given { border-color: var(--accent); border-width: 2px; }
        .input-group label { display: block; font-size: 0.75rem; color: var(--muted); margin-bottom: 4px; }
        .input-group input { width: 100%; background: transparent; border: none; color: white; font-size: 1.1rem; font-weight: 700; outline: none; }

        .hidden-ans { filter: blur(8px); pointer-events: none; user-select: none; color: #94a3b8 !important; }
        .revealed { color: var(--success) !important; filter: none !important; text-shadow: 0 0 10px rgba(34, 197, 94, 0.2); }
        .unit { position: absolute; right: 10px; bottom: 10px; font-size: 0.7rem; color: var(--muted); font-style: italic; }

        .visual-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; }
        .canvas-box { background: #0b1324; border-radius: 15px; padding: 15px; border: 1px solid #334155; text-align: center; }
        .canvas-box.full-width { grid-column: 1 / -1; }
        canvas { width: 100%; height: auto; border-radius: 8px; }
        h3 { font-size: 0.8rem; margin-bottom: 10px; color: var(--accent); text-transform: uppercase; }
        
        .legend { display: flex; justify-content: center; gap: 15px; font-size: 0.8rem; margin-top: 5px; }
        .dot-u { width: 8px; height: 8px; background: var(--accent); border-radius: 50%; }
        .dot-i { width: 8px; height: 8px; background: var(--current); border-radius: 50%; }
        .info-bar { background: #1a2b4e; padding: 8px 15px; border-radius: 8px; margin-bottom: 20px; font-size: 0.85rem; color: var(--accent); border-left: 4px solid var(--accent); }

        #solutionMethod {
            margin-top: 30px; background: #1e293b; padding: 25px;
            border-radius: 12px; border: 2px solid var(--success);
            display: none; margin-bottom: 30px;
        }
        .method-step { 
            margin-bottom: 12px; display: flex; align-items: flex-start; gap: 10px; 
            background: rgba(255,255,255,0.03); padding: 15px; border-radius: 10px; border-left: 4px solid var(--success);
        }
        .step-num { background: var(--success); color: #0f172a; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; }
        
        #hintBox {
            background: #2d3748; border-left: 4px solid var(--induct); 
            padding: 15px; margin-bottom: 20px; border-radius: 8px; display: none;
        }
    </style>
    <script type="application/ld+json">
    {
    "@context": "https://schema.org",
    "@type": "SoftwareApplication",
    "name": "RL Master Pro",
    "operatingSystem": "Web",
    "applicationCategory": "EducationalApplication",
    "description": "Calculateur interactif pour circuits √©lectriques RC en s√©rie avec trac√©s de Fresnel.",
    "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "EUR"
    }
    }
    </script>
</head>
<body>

<div class="container">
    <header>
        <div>
            <h1 style="font-size: 1.4rem;">RC Master <span style="color: var(--accent);">Pro</span> v12.8</h1>
            <p style="font-size: 0.85rem; color: var(--muted);">R√©solveur Universel RC S√©rie (par OM 2026.01.04)</p>
        </div>
    </header>

    <div id="currentTriplet" class="info-bar">
        Donn√©es d'entr√©e (al√©atoires) : <span id="tripletDisplay">-</span>
    </div>

    <div class="actions">
        <button class="btn-gen" onclick="generateExercise()">G√©n√©rer Nouveau Cas</button>
        <button id="btn-hint" style="background: var(--induct); color: #0f172a;" onclick="showHint()">Indice de r√©solution</button>
        <button class="btn-solve" onclick="revealAnswers()">V√©rifier / R√©v√©ler</button>
    </div>

    <div id="hintBox">
        <h3 style="color: var(--induct); margin-top: 0;">üí° Strat√©gie sugg√©r√©e</h3>
        <div id="hintText" style="font-size: 0.95rem;"></div>
    </div>

    <div class="grid" id="inputGrid"></div>

    <div id="solutionMethod">
        <h2 style="color: var(--success); margin-bottom: 10px; font-size: 1.4rem; border-bottom: 1px solid var(--success); padding-bottom: 10px;">
            üìö Guide de R√©solution D√©taill√©
        </h2>
        <div id="stepsList"></div>
    </div>

    <div class="visual-grid">
        <div class="canvas-box"><h3>Tensions [V]</h3><canvas id="fresnelU" width="300" height="220"></canvas></div>
        <div class="canvas-box"><h3>Imp√©dances [Œ©]</h3><canvas id="fresnelZ" width="300" height="220"></canvas></div>
        <div class="canvas-box"><h3>Puissances</h3><canvas id="fresnelS" width="300" height="220"></canvas></div>
        <div class="canvas-box full-width">
            <h3>Oscilloscope : u(t) & i(t)</h3>
            <canvas id="scopeCanvas" width="900" height="300"></canvas>
            <div class="legend">
                <span><div class="dot-u"></div> u(t)</span>
                <span><div class="dot-i"></div> i(t)</span>
                <span id="periodDisplay" style="color: var(--muted); margin-left: 20px;">T = ...</span>
            </div>
        </div>
    </div>
</div>

<script>
    const ALL_KEYS = [
        {id:"f", label:"Fr√©quence", unit:"Hz"}, {id:"L", label:"Inductance L", unit:"H"},
        {id:"U", label:"Tension Source U", unit:"V"}, {id:"I", label:"Courant I", unit:"A"}, 
        {id:"R", label:"R√©sistance R", unit:"Œ©"}, {id:"XC", label:"R√©actance XC", unit:"Œ©"}, 
        {id:"Z", label:"Imp√©dance Z", unit:"Œ©"}, {id:"UR", label:"Tension UR", unit:"V"}, 
        {id:"UC", label:"Tension UC", unit:"V"}, {id:"P", label:"Puissance P", unit:"W"}, 
        {id:"Q", label:"Puissance Q", unit:"var"}, {id:"S", label:"Puissance S", unit:"VA"}, 
        {id:"cos_phi", label:"cos œÜ", unit:"-"}, {id:"phi", label:"D√©phasage œÜ", unit:"¬∞"}
    ];

    const VARIABLE_BANKS = ["f", "L", "U", "I", "R", "XC", "Z", "UR", "UC", "P", "Q", "S", "cos_phi", "phi"];
    let STATE = { all: {}, triplet: [], revealed: false };

    const rad = (d) => d * Math.PI / 180;
    const deg = (r) => r * 180 / Math.PI;

        
    function computeAll(K) {
        let o = { ...K };
        for(let i=0; i<15; i++) {
            if (o.XC && o.L && o.L > 0) o.f = o.XC / (2 * Math.PI * o.L);
            if (o.f && o.L) o.XC = 2 * Math.PI * o.f * o.L;
            if (o.XC && o.f && o.f > 0) o.L = o.XC / (2 * Math.PI * o.f);
            if (o.R && o.XC) { o.Z = Math.sqrt(o.R**2 + o.XC**2); o.phi = deg(Math.atan2(o.XC, o.R)); o.cos_phi = o.R / o.Z; }
            if (o.Z && o.cos_phi) { o.R = o.Z * o.cos_phi; o.XC = Math.sqrt(Math.max(0, o.Z**2 - o.R**2)); o.phi = deg(Math.acos(o.cos_phi)); }
            if (o.I && o.Z) o.U = o.I * o.Z;
            if (o.U && o.Z) o.I = o.U / o.Z;
            if (o.U && o.I) o.Z = o.U / o.I;
            if (o.I && o.R) o.UR = o.I * o.R;
            if (o.I && o.XC) o.UC = o.I * o.XC;
            if (o.UR && o.UC) { o.U = Math.sqrt(o.UR**2 + o.UC**2); o.phi = deg(Math.atan2(o.UC, o.UR)); o.cos_phi = o.UR/o.U;}
            if (o.P && o.Q) { o.S = Math.sqrt(o.P**2 + o.Q**2); o.cos_phi = o.P / o.S; o.phi = deg(Math.acos(o.cos_phi)); }
            if (o.U && o.I) o.S = o.U * o.I;
            if (o.R && o.I) o.P = o.R * (o.I**2);
            if (o.XC && o.I) o.Q = o.XC * (o.I**2);

            if (o.P && o.I) o.R = o.P / (o.I**2);
            if (o.Q && o.I) o.XC = o.Q / (o.I**2);
            if (o.S && o.I) o.Z = o.S / (o.I**2);
            if (o.S && o.U) o.I = o.S / o.U;
            if (o.P && o.U && o.cos_phi) o.I = o.P / (o.U * o.cos_phi);
            if (o.P && o.S) o.cos_phi = o.P / o.S;
            if (o.phi) o.cos_phi = Math.cos(rad(o.phi));            
        }
        return o;
    }


function generateExercise() {
    document.getElementById('solutionMethod').style.display = 'none';
    document.getElementById('hintBox').style.display = 'none';
    
    let success = false;
    while (!success) {
        // --- NOUVELLE LOGIQUE DE S√âLECTION ---
        let pool = [...VARIABLE_BANKS];
        let triplet = [];

        // On force l'inclusion d'une puissance ou cos_phi pour varier
        const powers = ["P", "Q", "S", "cos_phi"];
        let forceKey = powers[Math.floor(Math.random() * powers.length)];
        triplet.push(forceKey);
        pool.splice(pool.indexOf(forceKey), 1);

        // On compl√®te avec 3 autres variables totalement au hasard
        for(let i=0; i<3; i++) {
            let idx = Math.floor(Math.random() * pool.length);
            triplet.push(pool.splice(idx, 1)[0]);
        }

        // --- G√âN√âRATION DE VALEURS ULTRA-AL√âATOIRES ---
        const seed = {
            f: Math.floor(Math.random() * 400) + 10,       // 10 √† 410 Hz
            L: Math.random() * 0.8 + 0.001,               // 1mH √† 800mH
            U: Math.floor(Math.random() * 990) + 10,      // 10V √† 1000V
            R: Math.floor(Math.random() * 490) + 10       // 10Œ© √† 500Œ©
        };

        const fullRef = computeAll(seed);
        let testKnown = {};
        triplet.forEach(k => testKnown[k] = fullRef[k]);

        const result = computeAll(testKnown);
        
        // V√©rification de la r√©solvabilit√©
        if (ALL_KEYS.every(k => result[k.id] !== undefined && !isNaN(result[k.id]) && isFinite(result[k.id]))) {
            STATE.all = result; 
            STATE.triplet = triplet; 
            STATE.revealed = false; 
            success = true;
        }
    }
    
    document.getElementById('tripletDisplay').textContent = STATE.triplet.join(' | ');
    updateUI();
}


    function updateUI() {
        const grid = document.getElementById('inputGrid');
        grid.innerHTML = ALL_KEYS.map(k => {
            const isKnown = STATE.triplet.includes(k.id);
            const val = k.id === "L" ? (STATE.all[k.id]).toFixed(4) : Math.round(STATE.all[k.id]*100)/100;
            return `
                <div class="input-group ${isKnown ? 'given' : ''}">
                    <label>${k.label}</label>
                    <input type="text" value="${val}" class="${!isKnown && !STATE.revealed ? 'hidden-ans' : (STATE.revealed && !isKnown ? 'revealed' : '')}" readonly>
                    <span class="unit">${k.unit}</span>
                </div>`;
        }).join('');
        document.getElementById('periodDisplay').textContent = `T = ${(1000/STATE.all.f).toFixed(1)}ms`;
        drawVisuals();
    }

function showHint() {
    const hintBox = document.getElementById('hintBox');
    const hintText = document.getElementById('hintText');
    hintBox.style.display = 'block';

    // Bloc de formules de base (non transform√©es)
    const formulaBlock = `
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; background: rgba(0,0,0,0.2); padding: 15px; border-radius: 8px; border: 1px dashed var(--induct);">
            <div style="text-align: center;">$$Z = \\sqrt{R^2 + X_C^2}\\quad [\\Omega]$$</div>
            <div style="text-align: center;">$$U = Z \\cdot I \\quad [V]$$</div>
            <div style="text-align: center;">$$\\cos\\varphi = \\frac{R}{Z} = \\frac{P}{S} = \\frac{U_R}{U}$$</div>
            <div style="text-align: center;">$$X_C = \\frac{1}{2\\pi f C} \\quad [\\Omega]$$</div>
            <div style="text-align: center;">$$S = U \\cdot I \\quad [V\\!\\!A]$$</div>
            <div style="text-align: center;">$$P = R \\cdot I^2\\quad [W]$$</div>
            <div style="text-align: center;">$$Q = X_C \\cdot I^2\\quad [var]$$</div>
            <div style="text-align: center;">$$S = \\sqrt{P^2 + Q^2}\\quad [V\\!\\!A]$$</div>
            <div style="text-align: center;">$$U = \\sqrt{U_R^2 + U_C^2}\\quad [V]$$</div>
            <div style="text-align: center;">$$U_R = R \\cdot I\\quad [V]$$</div>
        </div>
        <p style="margin-top: 15px; font-style: italic; color: var(--muted); text-align: center;">
            Identifiez les variables connues et isolez l'inconnue √† l'aide de ces relations fondamentales.
        </p>
    `;

    hintText.innerHTML = formulaBlock;
    
    if (window.MathJax) {
        MathJax.typesetPromise([hintText]);
    }
    
    hintBox.scrollIntoView({ behavior: 'smooth' });
}
function revealAnswers() {
    document.getElementById('hintBox').style.display = 'none'; // Masquer l'indice
    STATE.revealed = true;
    updateUI();
    const solDiv = document.getElementById('solutionMethod');
    const stepsList = document.getElementById('stepsList');
    solDiv.style.display = 'block';
    
    let html = "";
    let known = [...STATE.triplet]; 
    let stepIdx = 1;

    const logic = [
        // --- 1. TRIGONOM√âTRIE ET FACTEUR DE PUISSANCE ---
        { req: ['phi'], res: 'cos_phi', t: "Facteur de puissance", f: "\\cos\\varphi = \\cos(\\varphi) \\quad [-]" },
        { req: ['cos_phi'], res: 'phi', t: "Angle de d√©phasage", f: "\\varphi = \\arccos(\\cos\\varphi) \\quad [^\\circ]" },

        // --- 2. LOI D'OHM ET PUISSANCES DE BASE ---
        { req: ['P', 'U', 'cos_phi'], res: 'I', t: "Intensit√©", f: "I = \\frac{P}{U \\cdot \\cos\\varphi} \\quad [A]" },
        { req: ['U', 'Z'], res: 'I', t: "Intensit√© efficace (Loi d'Ohm)", f: "I = \\frac{U}{Z} \\quad [A]" },
        { req: ['S', 'I'], res: 'U', t: "Tension Source", f: "U = \\frac{S}{I} \\quad [V]" },
        { req: ['S', 'U'], res: 'I', t: "Intensit√© efficace", f: "I = \\frac{S}{U} \\quad [A]" },
        { req: ['U', 'I'], res: 'S', t: "Puissance apparente", f: "S = U \\cdot I \\quad [V\\!\\!A]" },

        // --- 3. TRIANGLE DES PUISSANCES ---
        { req: ['S', 'cos_phi'], res: 'P', t: "Puissance active", f: "P = S \\cdot \\cos\\varphi \\quad [W]" },
        { req: ['P', 'S'], res: 'cos_phi', t: "Facteur de puissance", f: "\\cos\\varphi = \\frac{P}{S} \\quad [-]" },
        { req: ['P', 'S'], res: 'Q', t: "Puissance r√©active", f: "Q = \\sqrt{S^2 - P^2} \\quad [var]" },
        { req: ['P', 'Q'], res: 'S', t: "Puissance apparente", f: "S = \\sqrt{P^2 + Q^2} \\quad [V\\!\\!A]" },
        { req: ['S', 'Q'], res: 'P', t: "Puissance active", f: "P = \\sqrt{S^2 - Q^2} \\quad [W]" },

        // --- 4. IMP√âDANCES ET COMPOSANTS (f, L, R, XC, Z) ---
        { req: ['U', 'I'], res: 'Z', t: "Imp√©dance totale", f: "Z = \\frac{U}{I} \\quad [\\Omega]" },
        { req: ['P', 'I'], res: 'R', t: "R√©sistance", f: "R = \\frac{P}{I^2} \\quad [\\Omega]" },
        { req: ['Q', 'I'], res: 'XC', t: "R√©actance capacitive", f: "X_C = \\frac{Q}{I^2} \\quad [\\Omega]" },
        { req: ['Z', 'cos_phi'], res: 'R', t: "R√©sistance", f: "R = Z \\cdot \\cos\\varphi \\quad [\\Omega]" },
        { req: ['Z', 'R'], res: 'XC', t: "R√©actance capacitive", f: "X_C = \\sqrt{Z^2 - R^2} \\quad [\\Omega]" },
        { req: ['R', 'XC'], res: 'Z', t: "Imp√©dance totale", f: "Z = \\sqrt{R^2 + X_C^2} \\quad [\\Omega]" },
        
        // Formules pour la fr√©quence et la capacit√©
        { req: ['XC', 'C'], res: 'f', t: "Fr√©quence du r√©seau", f: "f = \\frac{1}{2\\pi X_C C} \\quad [Hz]" },
        { req: ['XC', 'f'], res: 'C', t: "Capacit√©", f: "C = \\frac{1}{2\\pi f X_C} \\quad [C]" },
        { req: ['f', 'C'], res: 'XC', t: "R√©actance capacitive", f: "X_C = \\frac{1}{2\\pi f C} \\quad [\\Omega]" },

        // --- 5. TENSIONS PARTIELLES ---
        { req: ['I', 'R'], res: 'UR', t: "Tension R√©sistive", f: "U_R = R \\cdot I \\quad [V]" },
        { req: ['I', 'XC'], res: 'UC', t: "Tension Capacitive", f: "U_C = X_C \\cdot I \\quad [V]" },
        { req: ['UR', 'UC'], res: 'U', t: "Tension Source", f: "U = \\sqrt{U_R^2 + U_C^2} \\quad [V]" },
        { req: ['U', 'UR'], res: 'UC', t: "Tension Capacitive", f: "U_C = \\sqrt{U^2 - U_R^2} \\quad [V]" },
        { req: ['R', 'Z'], res: 'cos_phi', t: "Facteur de puissance", f: "\\cos\\varphi = \\frac{R}{Z} \\quad [-]" },
        { req: ['UR', 'U'], res: 'cos_phi', t: "Facteur de puissance", f: "\\cos\\varphi = \\frac{U_R}{U} \\quad [-]" }
    ];

    let foundNew;
    do {
        foundNew = false;
        logic.forEach(s => {
            if(!known.includes(s.res) && s.req.every(r => known.includes(r))) {
                html += `
                    <div class="method-step">
                        <div class="step-num">${stepIdx++}</div>
                        <div style="flex:1">
                            <b style="color: #64ffda;">${s.t} :</b>
                            <div style="background: #111b2d; padding: 12px; margin: 8px 0; border-radius: 8px; border-left: 3px solid #64ffda; color: #e6f1ff; font-size: 1.1em;">
                                $$ ${s.f} $$
                            </div>
                        </div>
                    </div>`;
                known.push(s.res);
                foundNew = true;
            }
        });
    } while(foundNew);

    stepsList.innerHTML = html;
    if (window.MathJax) MathJax.typesetPromise([stepsList]);
}


    function drawVisuals() {
        const drawTri = (id, hKey, vKey, hypKey, units) => {
            const canvas = document.getElementById(id);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 300, 220);

            const h = STATE.all[hKey], v = STATE.all[vKey], hyp = STATE.all[hypKey];
            const scale = 110 / Math.max(h, v, hyp || 1);
            
            // x0, y0 : Point d'origine (on remonte y0 car le triangle descend pour un circuit RC)
            const x0 = 45, y0 = 60; 
            const x1 = x0 + h * scale;
            const y1 = y0 + v * scale; // "+" car UC et XC pointent vers le bas

            // Dessin des segments
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#22c55e'; ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y0); ctx.stroke(); // R, UR ou P
            ctx.strokeStyle = '#a855f7'; ctx.beginPath(); ctx.moveTo(x1, y0); ctx.lineTo(x1, y1); ctx.stroke(); // XC, UC ou Q
            ctx.strokeStyle = '#38bdf8'; ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y1); ctx.stroke(); // Z, U ou S

            // Style du texte
            ctx.fillStyle = "white"; 
            ctx.font = "bold 10px Segoe UI"; 
            
            const getMod = (key, val, unit) => (STATE.triplet.includes(key) || STATE.revealed) 
                ? `${key} = ${Math.round(val * 10) / 10} [${unit}]` 
                : `${key} = ??? [${unit}]`;

            // Affichage des labels (ajust√©s pour la direction descendante)
            ctx.textAlign = "center";
            ctx.fillText(getMod(hKey, h, units[0]), x0 + (h * scale) / 2, y0 - 15); // Label horizontal (au-dessus)
            
            ctx.textAlign = "left";
            ctx.fillText(getMod(vKey, v, units[1]), x1 + 10, y0 + (v * scale) / 2); // Label vertical
            
            ctx.textAlign = "center";
            ctx.fillText(getMod(hypKey, hyp, units[2]), x0 + (h * scale) / 3, y1 + 15); // Label hypot√©nuse (en-dessous)
        };
        // Appels pour les 3 triangles RC
        drawTri('fresnelU', 'UR', 'UC', 'U', ['V', 'V', 'V']);
        drawTri('fresnelZ', 'R', 'XC', 'Z', ['Œ©', 'Œ©', 'Œ©']);
        drawTri('fresnelS', 'P', 'Q', 'S', ['W', 'var', 'VA']);

    // --- Partie Oscilloscope & Fresnel ---
    const scope = document.getElementById('scopeCanvas');
    const sCtx = scope.getContext('2d');
    const w = scope.width, h = scope.height, midY = h / 2;

    sCtx.clearRect(0, 0, w, h);

    // Configuration G√©om√©trique
    const centerX = 100; 
    const fresnelRadius = 60; 
    const tangentX = centerX + fresnelRadius; // Point t=0
    const scopeWidth = w - tangentX - 40;
    
    // Pour un circuit RC, le d√©phasage phi est n√©gatif (phi = -atan(1/RCw))
    // On r√©cup√®re la valeur absolue pour les calculs de dessin afin de g√©rer l'avance
    const phiValue = STATE.all.phi || 0;
    const phiRad = rad(phiValue); 
    const freq = (2 * Math.PI * 2) / scopeWidth; // 2 p√©riodes

    // --- 1. FONCTIONS UTILITAIRES POUR FL√àCHES ET LABELS ---
    const drawLatexArrow = (ctx, x1, y1, x2, y2, size = 10, color = null) => {
        const angle = Math.atan2(y2 - y1, x2 - x1);
        ctx.save();
        if (color) {
            ctx.fillStyle = color;
        } else {
            ctx.fillStyle = ctx.strokeStyle;
        }
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - size * Math.cos(angle - Math.PI / 8), y2 - size * Math.sin(angle - Math.PI / 8));
        ctx.lineTo(x2 - size * Math.cos(angle + Math.PI / 8), y2 - size * Math.sin(angle + Math.PI / 8));
        ctx.fill();
        ctx.restore();
    };

    const drawVectorLabel = (ctx, x, y, text, color, position = "above") => {
        ctx.fillStyle = color;
        ctx.font = "italic bold 16px serif";
        const lx = x - 25; 
        const ly = (position === "above") ? y - 12 : y + 25;
        ctx.fillText(text, lx, ly);
        ctx.lineWidth = 1;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(lx, ly - 15); ctx.lineTo(lx + 12, ly - 15);
        ctx.stroke();
        drawLatexArrow(ctx, lx, ly - 15, lx + 14, ly - 15, 5);
    };

    // --- 2. DESSIN DES AXES ---
    sCtx.strokeStyle = "#475569";
    sCtx.fillStyle = "#475569";
    sCtx.lineWidth = 1;

    // Axe Horizontal (t)
    sCtx.beginPath(); sCtx.moveTo(20, midY); sCtx.lineTo(w - 20, midY); sCtx.stroke();
    drawLatexArrow(sCtx, w - 30, midY, w - 15, midY);
    sCtx.font = "12px Arial";
    sCtx.fillText("t [s]", w - 30, midY + 20);

    // Axe Vertical Central (Cercle)
    sCtx.beginPath(); sCtx.moveTo(centerX, h - 20); sCtx.lineTo(centerX, 20); sCtx.stroke();
    drawLatexArrow(sCtx, centerX, 30, centerX, 15);

    // Axe Vertical Tangent (t=0)
    sCtx.lineWidth = 2;
    sCtx.beginPath(); sCtx.moveTo(tangentX, h - 20); sCtx.lineTo(tangentX, 20); sCtx.stroke();
    drawLatexArrow(sCtx, tangentX, 30, tangentX, 15);
    sCtx.fillText("u(t), i(t)", tangentX + 8, 25);

    // --- 3. DIAGRAMME DE FRESNEL ---
    sCtx.strokeStyle = "#334155";
    sCtx.lineWidth = 1;
    sCtx.beginPath(); sCtx.arc(centerX, midY, fresnelRadius, 0, Math.PI * 2); sCtx.stroke();
    
    // Sens Trigonom√©trique œâ
    sCtx.strokeStyle = "#94a3b8";
    sCtx.beginPath();
    const startA = -Math.PI/2.2, endA = -Math.PI/1.6;
    sCtx.arc(centerX, midY, fresnelRadius + 18, startA, endA, true);
    sCtx.stroke();
    const ox = centerX + (fresnelRadius+18) * Math.cos(endA);
    const oy = midY + (fresnelRadius+18) * Math.sin(endA);
    drawLatexArrow(sCtx, ox + 5, oy - 2, ox, oy, 7);
    sCtx.font = "italic 16px serif";
    sCtx.fillText("œâ", ox - 15, oy - 5);

    // Vecteur U (R√©f√©rence √† 0¬∞)
    const uX = centerX + fresnelRadius;
    sCtx.strokeStyle = "#38bdf8";
    sCtx.lineWidth = 3;
    sCtx.beginPath(); sCtx.moveTo(centerX, midY); sCtx.lineTo(uX, midY); sCtx.stroke();
    drawLatexArrow(sCtx, centerX, midY, uX, midY, 10, "#38bdf8");
    drawVectorLabel(sCtx, uX, midY, "U", "#38bdf8", "below");

    // Vecteur I (EN AVANCE : i(t) = Imax*sin(wt + |phi|))
    // On utilise Math.abs(phiRad) pour s'assurer que I est au-dessus de U (avance)
    const currentPhi = Math.abs(phiRad);
    const iX = centerX + Math.cos(-currentPhi) * (fresnelRadius * 0.85);
    const iY = midY + Math.sin(-currentPhi) * (fresnelRadius * 0.85);
    sCtx.strokeStyle = "#f472b6";
    sCtx.lineWidth = 3;
    sCtx.beginPath(); sCtx.moveTo(centerX, midY); sCtx.lineTo(iX, iY); sCtx.stroke();
    drawLatexArrow(sCtx, centerX, midY, iX, iY, 10, "#f472b6");    
    drawVectorLabel(sCtx, iX, iY, "I", "#f472b6", "above");

    // Arc pour l'angle phi entre U et I
    sCtx.strokeStyle = "#f59e0b";
    sCtx.lineWidth = 1.5;
    sCtx.beginPath();
    sCtx.arc(centerX, midY, 35, 0, -currentPhi, true); 
    sCtx.stroke();
    sCtx.fillStyle = "#f59e0b";
    sCtx.font = "italic bold 20px serif"; 
    sCtx.fillText("œÜ", centerX + 45 * Math.cos(-currentPhi/2), midY + 45 * Math.sin(-currentPhi/2));

    // --- 4. SIGNAUX SUR OSCILLOSCOPE ---
    const drawSignal = (color, amp, phase) => {
        sCtx.beginPath();
        sCtx.strokeStyle = color;
        sCtx.lineWidth = 2;
        for (let x = 0; x <= scopeWidth; x++) {
            // La phase positive dans le sinus d√©cale la courbe vers la gauche (avance)
            const y = midY - Math.sin(x * freq + phase) * amp;
            x === 0 ? sCtx.moveTo(tangentX + x, y) : sCtx.lineTo(tangentX + x, y);
        }
        sCtx.stroke();
    };

    // U(t) = Um sin(wt) -> phase 0
    drawSignal("#38bdf8", fresnelRadius, 0); 
    // I(t) = Im sin(wt + |phi|) -> En avance pour RC
    drawSignal("#f472b6", fresnelRadius * 0.7, currentPhi);

    // D√©phasage œÜ visuel sur l'axe
    const zeroU = Math.PI / freq; 
    const zeroI = (Math.PI - currentPhi) / freq; // Le zero de I arrive AVANT celui de U
    const yBase = midY + 45;

    sCtx.strokeStyle = "#f59e0b";
    sCtx.setLineDash([4, 2]);
    sCtx.beginPath();
    sCtx.moveTo(tangentX + zeroU, midY); sCtx.lineTo(tangentX + zeroU, yBase + 10);
    sCtx.moveTo(tangentX + zeroI, midY); sCtx.lineTo(tangentX + zeroI, yBase + 10);
    sCtx.stroke();
    sCtx.setLineDash([]);

    // Fl√®che œÜ double sens
    sCtx.lineWidth = 1.5;
    sCtx.beginPath();
    sCtx.moveTo(tangentX + zeroU, yBase); sCtx.lineTo(tangentX + zeroI, yBase);
    sCtx.stroke();
    drawLatexArrow(sCtx, tangentX + zeroI + 5, yBase, tangentX + zeroI, yBase, 6);
    drawLatexArrow(sCtx, tangentX + zeroU - 5, yBase, tangentX + zeroU, yBase, 6);
    sCtx.fillText("œÜ", tangentX + (zeroU + zeroI)/2 - 8, yBase + 22);
    }
    window.onload = generateExercise;
</script>
</body>
</html>