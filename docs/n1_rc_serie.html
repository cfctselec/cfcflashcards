<!DOCTYPE html>
<html lang="fr">
<head>
<link rel="sitemap" type="application/xml" title="Sitemap" href="/sitemap.xml" />
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RC Master Pro â€“ RÃ©solution PÃ©dagogique</title>
<meta name="description" content="Calculateur pÃ©dagogique pour circuits RC sÃ©rie. RÃ©solution en 10 Ã©tapes logiques garanties.">
<meta name="keywords" content="circuit RC, Ã©lectricitÃ©, impÃ©dance, dÃ©phasage, puissance, mÃ©thode pÃ©dagogique">
<meta name="author" content="OM 2026">
<meta name="robots" content="index, follow">
<link rel="icon" type="png" href="16BB.svg">
<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    processEscapes: true,
    processEnvironments: true
  },
  options: {
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    ignoreHtmlClass: 'tex2jax_ignore'
  },
  startup: {
    pageReady: () => {
      return MathJax.startup.defaultPageReady();
    }
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<style>
:root {
  --bg: #0f172a; --card: #1e293b; --accent: #38bdf8;
  --text: #f1f5f9; --muted: #94a3b8; --success: #22c55e;
  --warn: #f43f5e; --capacit: #a855f7; --current: #f472b6;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); padding: 15px; line-height: 1.4; }
.container { max-width: 1200px; margin: 0 auto; }
header {
  display: flex; align-items: center; justify-content: space-between;
  background: var(--card); padding: 15px 20px; border-radius: 12px;
  border: 1px solid #334155; margin-bottom: 20px;
}
.actions { display: flex; gap: 10px; margin-bottom: 20px; }
button {
  flex: 1; padding: 12px; border-radius: 8px; border: none;
  cursor: pointer; font-weight: 700; transition: 0.3s;
  text-transform: uppercase;
}
.btn-gen { background: var(--accent); color: #0f172a; }
.btn-solve { background: var(--success); color: #0f172a; }
button:hover { opacity: 0.9; transform: translateY(-1px); }
.grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
  gap: 12px; margin-bottom: 25px;
}
.input-group {
  background: var(--card); padding: 10px 14px; border-radius: 10px;
  border: 1px solid #334155; position: relative;
}
.input-group.given { border-color: var(--accent); border-width: 2px; }
.input-group label { display: block; font-size: 0.75rem; color: var(--muted); margin-bottom: 4px; }
.input-group input { width: 100%; background: transparent; border: none; color: white; font-size: 1.1rem; font-weight: 700; outline: none; }
.hidden-ans { filter: blur(8px); pointer-events: none; user-select: none; color: #94a3b8 !important; }
.revealed { color: var(--success) !important; filter: none !important; text-shadow: 0 0 10px rgba(34, 197, 94, 0.2); }
.unit { position: absolute; right: 10px; bottom: 10px; font-size: 0.7rem; color: var(--muted); font-style: italic; }
.visual-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; }
.canvas-box { background: #0b1324; border-radius: 15px; padding: 15px; border: 1px solid #334155; text-align: center; }
.canvas-box.full-width { grid-column: 1 / -1; }
canvas { width: 100%; height: auto; border-radius: 8px; }
h3 { font-size: 0.8rem; margin-bottom: 10px; color: var(--accent); text-transform: uppercase; }
.legend { display: flex; justify-content: center; gap: 15px; font-size: 0.8rem; margin-top: 5px; }
.dot-u { width: 8px; height: 8px; background: var(--accent); border-radius: 50%; }
.dot-i { width: 8px; height: 8px; background: var(--current); border-radius: 50%; }
.info-bar { background: #1a2b4e; padding: 8px 15px; border-radius: 8px; margin-bottom: 20px; font-size: 0.85rem; color: var(--accent); border-left: 4px solid var(--accent); }
#solutionMethod {
  margin-top: 30px; background: #1e293b; padding: 25px;
  border-radius: 12px; border: 2px solid var(--success);
  display: none; margin-bottom: 30px;
}
.method-step {
  margin-bottom: 12px; display: flex; align-items: flex-start; gap: 10px;
  background: rgba(255,255,255,0.03); padding: 15px; border-radius: 10px; border-left: 4px solid var(--success);
}
.step-num { background: var(--success); color: #0f172a; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; }
#hintBox {
  background: #2d3748; border-left: 4px solid var(--capacit);
  padding: 15px; margin-bottom: 20px; border-radius: 8px; display: none;
}
#tripletDisplay {
  font-family: 'Courier New', monospace;
  font-weight: bold;
  color: var(--accent);
}
#unknownsDisplay {
  font-family: 'Courier New', monospace;
  font-weight: bold;
}
</style>
</head>
<body>
<div class="container">
<header>
  <div>
    <h1 style="font-size: 1.4rem;">RC Master <span style="color: var(--accent);">Pro</span> â€“ PÃ©dagogique</h1>
    <p style="font-size: 0.85rem; color: var(--muted);">RÃ©solution en 10 Ã©tapes logiques garanties</p>
  </div>
</header>

<div id="currentTriplet" class="info-bar">
  <strong>DonnÃ©es d'entrÃ©e :</strong>
  <span id="tripletDisplay" style="margin-left: 10px;">-</span><br>
  <strong>Inconnues :</strong>
  <span id="unknownsDisplay" style="margin-left: 10px; color: var(--warn);">-</span>
</div>

<div class="actions">
  <button class="btn-gen" onclick="generateExercise()">GÃ©nÃ©rer Nouveau Cas</button>
  <button id="btn-hint" style="background: var(--capacit); color: #0f172a;" onclick="showHint()">Indice de rÃ©solution</button>
  <button class="btn-solve" onclick="revealAnswers()">VÃ©rifier / RÃ©vÃ©ler</button>
</div>

<div id="hintBox">
  <h3 style="color: var(--capacit); margin-top: 0;">ðŸ’¡ Ordre pÃ©dagogique utilisÃ©</h3>
  <div style="color: var(--text); font-size: 0.95rem;">
    1. Calcul de \(X_C\) â†’ 2. ImpÃ©dance \(Z\) â†’ 3. Courant \(I\) â†’<br>
    4. Tensions \(U_R\), \(U_C\) â†’ 5. Facteur de puissance \(\cos\varphi\) â†’<br>
    6. DÃ©phasage \(\varphi\) â†’ 7. Puissances \(P\), \(Q\), \(S\)
  </div>
</div>

<div class="grid" id="inputGrid"></div>

<div id="solutionMethod">
  <h2 style="color: var(--success); margin-bottom: 10px; font-size: 1.4rem; border-bottom: 1px solid var(--success); padding-bottom: 10px;">
    ðŸ“š Guide de RÃ©solution
  </h2>
  <div id="stepsList"></div>
</div>

<div class="visual-grid">
  <div class="canvas-box"><h3>Tensions [V]</h3><canvas id="fresnelU" width="300" height="220"></canvas></div>
  <div class="canvas-box"><h3>ImpÃ©dances [Î©]</h3><canvas id="fresnelZ" width="300" height="220"></canvas></div>
  <div class="canvas-box"><h3>Puissances</h3><canvas id="fresnelS" width="300" height="220"></canvas></div>
  <div class="canvas-box full-width">
    <h3>Oscilloscope : u(t) & i(t)</h3>
    <canvas id="scopeCanvas" width="900" height="300"></canvas>
    <div class="legend">
      <span><div class="dot-u"></div> u(t)</span>
      <span><div class="dot-i"></div> i(t)</span>
      <span id="periodDisplay" style="color: var(--muted); margin-left: 20px;">T = ...</span>
    </div>
  </div>
</div>

</div>

<script>
// ==================== BIBLIOTHÃˆQUE DE FORMULES ====================
const FORMULA_LIBRARY = {
  XC: [
    { requires: ['f', 'C'], formula: 'X_C = \\frac{1}{2\\pi f C}', calc: (v) => 1 / (2 * Math.PI * v.f * v.C) },
    { requires: ['Z', 'R'], formula: 'X_C = \\sqrt{Z^2 - R^2}', calc: (v) => Math.sqrt(Math.max(0, v.Z*v.Z - v.R*v.R)) },
    { requires: ['UC', 'I'], formula: 'X_C = \\frac{U_C}{I}', calc: (v) => v.UC / v.I },
    { requires: ['Q', 'I'], formula: 'X_C = \\frac{|Q|}{I^2}', calc: (v) => Math.abs(v.Q) / (v.I * v.I) }
  ],
  Z: [
    { requires: ['R', 'XC'], formula: 'Z = \\sqrt{R^2 + X_C^2}', calc: (v) => Math.sqrt(v.R*v.R + v.XC*v.XC) },
    { requires: ['U', 'I'], formula: 'Z = \\frac{U}{I}', calc: (v) => v.U / v.I },
    { requires: ['R', 'cos_phi'], formula: 'Z = \\frac{R}{\\cos\\varphi}', calc: (v) => v.R / v.cos_phi }
  ],
  I: [
    { requires: ['U', 'Z'], formula: 'I = \\frac{U}{Z}', calc: (v) => v.U / v.Z },
    { requires: ['UR', 'R'], formula: 'I = \\frac{U_R}{R}', calc: (v) => v.UR / v.R },
    { requires: ['UC', 'XC'], formula: 'I = \\frac{U_C}{X_C}', calc: (v) => v.UC / v.XC },
    { requires: ['P', 'R'], formula: 'I = \\sqrt{\\frac{P}{R}}', calc: (v) => Math.sqrt(v.P / v.R) },
    { requires: ['S', 'U'], formula: 'I = \\frac{S}{U}', calc: (v) => v.S / v.U }
  ],
  UR: [
    { requires: ['R', 'I'], formula: 'U_R = R \\cdot I', calc: (v) => v.R * v.I },
    { requires: ['U', 'cos_phi'], formula: 'U_R = U \\cdot \\cos\\varphi', calc: (v) => v.U * v.cos_phi },
    { requires: ['U', 'UC'], formula: 'U_R = \\sqrt{U^2 - U_C^2}', calc: (v) => Math.sqrt(Math.max(0, v.U*v.U - v.UC*v.UC)) },
    { requires: ['P', 'I'], formula: 'U_R = \\frac{P}{I}', calc: (v) => v.P / v.I }
  ],
  UC: [
    { requires: ['XC', 'I'], formula: 'U_C = X_C \\cdot I', calc: (v) => v.XC * v.I },
    { requires: ['U', 'UR'], formula: 'U_C = \\sqrt{U^2 - U_R^2}', calc: (v) => Math.sqrt(Math.max(0, v.U*v.U - v.UR*v.UR)) },
    { requires: ['Q', 'I'], formula: 'U_C = \\frac{|Q|}{I}', calc: (v) => Math.abs(v.Q) / v.I }
  ],
  P: [
    { requires: ['R', 'I'], formula: 'P = R \\cdot I^2', calc: (v) => v.R * v.I * v.I },
    { requires: ['UR', 'I'], formula: 'P = U_R \\cdot I', calc: (v) => v.UR * v.I },
    { requires: ['S', 'cos_phi'], formula: 'P = S \\cdot \\cos\\varphi', calc: (v) => v.S * v.cos_phi },
    { requires: ['S', 'Q'], formula: 'P = \\sqrt{S^2 - Q^2}', calc: (v) => Math.sqrt(Math.max(0, v.S*v.S - v.Q*v.Q)) }
  ],
  Q: [
    { requires: ['XC', 'I'], formula: 'Q = -X_C \\cdot I^2', calc: (v) => -(v.XC * v.I * v.I) },
    { requires: ['UC', 'I'], formula: 'Q = -U_C \\cdot I', calc: (v) => -(v.UC * v.I) },
    { requires: ['S', 'P'], formula: 'Q = -\\sqrt{S^2 - P^2}', calc: (v) => -Math.sqrt(Math.max(0, v.S*v.S - v.P*v.P)) }
  ],
  S: [
    { requires: ['U', 'I'], formula: 'S = U \\cdot I', calc: (v) => v.U * v.I },
    { requires: ['P', 'Q'], formula: 'S = \\sqrt{P^2 + Q^2}', calc: (v) => Math.sqrt(v.P*v.P + v.Q*v.Q) },
    { requires: ['P', 'cos_phi'], formula: 'S = \\frac{P}{\\cos\\varphi}', calc: (v) => v.P / v.cos_phi }
  ],
  cos_phi: [
    { requires: ['R', 'Z'], formula: '\\cos\\varphi = \\frac{R}{Z}', calc: (v) => v.R / v.Z },
    { requires: ['P', 'S'], formula: '\\cos\\varphi = \\frac{P}{S}', calc: (v) => v.P / v.S },
    { requires: ['UR', 'U'], formula: '\\cos\\varphi = \\frac{U_R}{U}', calc: (v) => v.UR / v.U }
  ],
  phi: [
    { requires: ['cos_phi'], formula: '\\varphi = -\\arccos(\\cos\\varphi)', calc: (v) => -Math.acos(v.cos_phi) * 180 / Math.PI },
    { requires: ['R', 'XC'], formula: '\\varphi = -\\arctan\\left(\\frac{X_C}{R}\\right)', calc: (v) => -Math.atan2(v.XC, v.R) * 180 / Math.PI }
  ],
  C: [
    { requires: ['f', 'XC'], formula: 'C = \\frac{1}{2\\pi f X_C}', calc: (v) => 1 / (2 * Math.PI * v.f * v.XC) }
  ],
  f: [
    { requires: ['C', 'XC'], formula: 'f = \\frac{1}{2\\pi C X_C}', calc: (v) => 1 / (2 * Math.PI * v.C * v.XC) }
  ]
};

const ALL_KEYS = [
  {id:"f", label:"FrÃ©quence", unit:"Hz"}, {id:"C", label:"CapacitÃ© C", unit:"F"},
  {id:"U", label:"Tension Source U", unit:"V"}, {id:"I", label:"Courant I", unit:"A"},
  {id:"R", label:"RÃ©sistance R", unit:"Î©"}, {id:"XC", label:"RÃ©actance XC", unit:"Î©"},
  {id:"Z", label:"ImpÃ©dance Z", unit:"Î©"}, {id:"UR", label:"Tension UR", unit:"V"},
  {id:"UC", label:"Tension UC", unit:"V"}, {id:"P", label:"Puissance P", unit:"W"},
  {id:"Q", label:"Puissance Q", unit:"var"}, {id:"S", label:"Puissance S", unit:"VA"},
  {id:"cos_phi", label:"cos Ï†", unit:"-"}, {id:"phi", label:"Angle de dÃ©phasage Ï†", unit:"Â°"}
];

// ==================== COMBINAISONS IMPOSSIBLES ====================
const impossibleCombinations = [
  ['P', 'Q', 'S', 'cosÏ†'],
  ['P', 'Q', 'S', 'phi'],
  ['P', 'Q', 'cosÏ†', 'phi'],
  ['P', 'S', 'cosÏ†', 'phi'],
  ['Q', 'S', 'cosÏ†', 'phi'],
  ['C', 'R', 'cosÏ†', 'f'],
  ['C', 'R', 'f', 'phi'],
  ['U', 'UC', 'UR', 'cosÏ†'],
  ['U', 'UC', 'UR', 'phi'],
  ['I', 'S', 'U', 'Z'],
  ['UR', 'UC', 'cosÏ†', 'phi'],
  ['U', 'UR', 'cosÏ†', 'phi'],
  ['U', 'UC', 'cosÏ†', 'phi'],
  ['R', 'Z', 'cosÏ†', 'phi']
].map(arr => arr.sort());

function isCombinationImpossible(selected) {
  if (selected.length !== 4) return false;
  const sortedSelected = [...selected].sort();
  return impossibleCombinations.some(impossible =>
    impossible.length === 4 && impossible.every((val, i) => val === sortedSelected[i])
  );
}

let STATE = { all: {}, triplet: [], revealed: false };
const rad = (d) => d * Math.PI / 180;
const deg = (r) => r * 180 / Math.PI;

// ==================== ORDRE PÃ‰DAGOGIQUE FIXE ====================
const PEDAGOGICAL_ORDER = [
  'XC', 'Z', 'I', 'UR', 'UC', 'cos_phi', 'phi', 'P', 'Q', 'S'
];

function findResolutionPath(knownVars, initialValues) {
  const resolved = new Set(knownVars);
  const allValues = { ...initialValues };
  const path = [];
  const maxSteps = 10;
  let changed = true;

  // Tant qu'on trouve au moins une variable calculable
  while (changed && path.length < maxSteps) {
    changed = false;

    // Parcourir dans l'ordre pÃ©dagogique
    for (const target of PEDAGOGICAL_ORDER) {
      if (resolved.has(target)) continue;

      const formulas = FORMULA_LIBRARY[target];
      if (!formulas) continue;

      for (const formulaDef of formulas) {
        if (formulaDef.requires.every(req => resolved.has(req))) {
          try {
            const reqValues = {};
            let allReqValid = true;
            for (const req of formulaDef.requires) {
              if (allValues[req] === undefined || isNaN(allValues[req]) || !isFinite(allValues[req])) {
                allReqValid = false;
                break;
              }
              reqValues[req] = allValues[req];
            }
            if (!allReqValid) continue;

            const result = formulaDef.calc(reqValues);
            if (isNaN(result) || !isFinite(result)) continue;

            // Ajouter l'Ã©tape
            path.push({
              step: path.length + 1,
              target: target,
              varLabel: ALL_KEYS.find(k => k.id === target)?.label || target,
              formula: formulaDef.formula,
              requires: [...formulaDef.requires],
              reqValues: { ...reqValues },
              result: result
            });

            allValues[target] = result;
            resolved.add(target);
            changed = true;
            break; // Passer Ã  la prochaine itÃ©ration globale (pour respecter l'ordre)
          } catch (e) {
            console.warn(`Erreur calcul ${target}:`, e.message);
          }
        }
      }

      // Si on a rÃ©solu une variable, on redÃ©marre la boucle depuis le dÃ©but de l'ordre pÃ©dagogique
      if (changed) break;
    }
  }

  return path;
}

function computeAll(K) {
  let o = { ...K };
  Object.keys(o).forEach(key => {
    if (typeof o[key] === 'number') {
      o[key] = parseFloat(o[key].toFixed(10));
    }
  });
  if (o.f && o.C) o.XC = 1 / (2 * Math.PI * o.f * o.C);
  else if (o.f && o.XC) o.C = 1 / (2 * Math.PI * o.f * o.XC);
  else if (o.XC && o.C) o.f = 1 / (2 * Math.PI * o.XC * o.C);
  if (o.R && o.XC) o.Z = Math.sqrt(o.R*o.R + o.XC*o.XC);
  else if (o.Z && o.R) o.XC = Math.sqrt(Math.max(0, o.Z*o.Z - o.R*o.R));
  else if (o.Z && o.XC) o.R = Math.sqrt(Math.max(0, o.Z*o.Z - o.XC*o.XC));
  if (o.R && o.XC) o.phi = -deg(Math.atan2(o.XC, o.R));
  if (o.R && o.Z && o.Z !== 0) o.cos_phi = o.R / o.Z;
  if (o.phi) o.cos_phi = Math.cos(rad(o.phi));
  if (o.cos_phi) o.phi = -deg(Math.acos(o.cos_phi));
  if (o.Z && o.I) o.U = o.Z * o.I;
  else if (o.U && o.Z) o.I = o.U / o.Z;
  else if (o.U && o.I) o.Z = o.U / o.I;
  if (o.I && o.R) o.UR = o.I * o.R;
  if (o.I && o.XC) o.UC = o.I * o.XC;
  if (o.UR && o.UC) o.U = Math.sqrt(o.UR*o.UR + o.UC*o.UC);
  if (o.U && o.I) o.S = o.U * o.I;
  if (o.R && o.I) o.P = o.R * o.I * o.I;
  if (o.XC && o.I) o.Q = -(o.XC * o.I * o.I);
  if (o.P && o.Q) o.S = Math.sqrt(o.P*o.P + o.Q*o.Q);
  if (o.S && o.cos_phi) o.P = o.S * o.cos_phi;
  if (o.S && o.P && o.S !== 0) o.cos_phi = o.P / o.S;
  if (o.S && o.P) o.Q = -Math.sqrt(Math.max(0, o.S*o.S - o.P*o.P));
  if (o.P && o.I && o.I !== 0) o.R = o.P / (o.I * o.I);
  if (o.Q && o.I && o.I !== 0) o.XC = -o.Q / (o.I * o.I);
  if (o.S && o.U && o.U !== 0) o.I = o.S / o.U;

  return o;
}

function formatValue(key, value) {
  if (value === undefined || isNaN(value)) return "?";
  if (key === "C") return (value * 1e6).toFixed(2) + " ÂµF";
  if (key === "phi") return value.toFixed(1) + "Â°"; // 1 dÃ©cimale pour l'angle
  if (key === "cos_phi") return value.toFixed(3);   // 3 dÃ©cimales pour cosÏ†
  // Pour les autres grandeurs : 2 dÃ©cimales
  return value.toFixed(2);
}   

function formatResolutionStep(step) {
  return `
  <div class="method-step">
    <div class="step-num">${step.step}</div>
    <div style="flex:1">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <b style="color: var(--success); font-size: 1.1rem;">${step.varLabel}</b>
        <span style="font-size: 0.85rem; color: var(--muted); font-family: monospace;">${step.target}</span>
      </div>
      <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; margin-bottom: 8px; text-align: center;">
        \\(\\displaystyle ${step.formula}\\)
      </div>
    </div>
  </div>`;
}

function generateExercise() {
  document.getElementById('solutionMethod').style.display = 'none';
  document.getElementById('hintBox').style.display = 'none';

  const base = {
    f: Math.floor(Math.random() * 400) + 50,
    C: parseFloat((Math.random() * 100 + 10).toFixed(6)) * 1e-6,
    U: Math.floor(Math.random() * 400) + 50,
    R: Math.floor(Math.random() * 300) + 20
  };

  const allValues = computeAll(base);
  let triplet;
  let attempts = 0;
  const allIds = ALL_KEYS.map(k => k.id);

  do {
    const shuffled = [...allIds].sort(() => Math.random() - 0.5);
    triplet = shuffled.slice(0, 4);
    attempts++;
  } while (isCombinationImpossible(triplet) && attempts < 30);

  if (isCombinationImpossible(triplet)) {
    triplet = ['U', 'R', 'C', 'f'];
  }

  STATE.all = allValues;
  STATE.triplet = triplet;
  STATE.revealed = false;

  const tripletDisplay = triplet.map(id => {
    const key = ALL_KEYS.find(k => k.id === id);
    let value = STATE.all[id];
    if (id === "C") value = (value * 1e6).toFixed(2) + " ÂµF";
    else if (id === "phi") value = Math.round(value * 10) / 10;
    else value = Math.round(value * 100) / 100;
    return `${id} = ${value} [${key.unit}]`;
  }).join('  |  ');

  const unknowns = ALL_KEYS.filter(k => !triplet.includes(k.id)).map(k => k.id);
  document.getElementById('tripletDisplay').textContent = tripletDisplay;
  document.getElementById('unknownsDisplay').textContent = unknowns.join(', ');
  updateUI();
}

function updateUI() {
  const grid = document.getElementById('inputGrid');
  grid.innerHTML = ALL_KEYS.map(k => {
    const isKnown = STATE.triplet.includes(k.id);
    let val;
    if (k.id === "C") val = (STATE.all[k.id] * 1e6).toFixed(2) + " ÂµF";
    else if (k.id === "phi") val = Math.round(STATE.all[k.id] * 10) / 10;
    else val = Math.round(STATE.all[k.id] * 100) / 100;
    return `
    <div class="input-group ${isKnown ? 'given' : ''}">
      <label>${k.label}</label>
      <input type="text" value="${val}" class="${!isKnown && !STATE.revealed ? 'hidden-ans' : (STATE.revealed && !isKnown ? 'revealed' : '')}" readonly>
      <span class="unit">${k.unit}</span>
    </div>`;
  }).join('');
  document.getElementById('periodDisplay').textContent = `T = ${(1000/STATE.all.f).toFixed(1)}ms`;
  drawVisuals();
}

function showHint() {
  document.getElementById('hintBox').style.display = 'block';
}

function revealAnswers() {
  document.getElementById('unknownsDisplay').textContent = "Toutes rÃ©solues âœ“";
  document.getElementById('unknownsDisplay').style.color = "var(--success)";
  document.getElementById('hintBox').style.display = 'none';
  STATE.revealed = true;
  updateUI();

  const solDiv = document.getElementById('solutionMethod');
  const stepsList = document.getElementById('stepsList');
  solDiv.style.display = 'block';

  // Initialiser avec seulement les 4 grandeurs du triplet
  const initialValues = {};
  STATE.triplet.forEach(id => {
    initialValues[id] = STATE.all[id];
  });

  const resolutionPath = findResolutionPath(STATE.triplet, initialValues);
  const expectedSteps = PEDAGOGICAL_ORDER.filter(id => !STATE.triplet.includes(id)).length;

  let html = "";
  const knownVars = STATE.triplet.map(id => {
    const key = ALL_KEYS.find(k => k.id === id);
    const val = formatValue(id, STATE.all[id]);
    const unit = key?.unit || '';
    return `<span style="color: var(--accent); font-weight: bold;">${id}</span> = ${val} ${unit}`;
  }).join(' &nbsp;|&nbsp; ');



  if (resolutionPath.length === expectedSteps) {

    resolutionPath.forEach(step => html += formatResolutionStep(step));
  } else {

    resolutionPath.forEach(step => html += formatResolutionStep(step));
  }

  stepsList.innerHTML = html;
  if (window.MathJax) {
    setTimeout(() => {
      MathJax.typesetPromise([stepsList]).catch(err => console.error('MathJax error:', err));
    }, 100);
  }
  solDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
}

function drawVisuals() {
  const drawTri = (id, hKey, vKey, hypKey, units) => {
    const canvas = document.getElementById(id);
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 300, 220);
    const h = STATE.all[hKey], v = Math.abs(STATE.all[vKey]), hyp = STATE.all[hypKey];
    const scale = 110 / Math.max(h, v, hyp || 1);
    const x0 = 45, y0 = 175, x1 = x0 + h * scale, y1 = y0 - v * scale;
    const getMod = (key, val, unit) => (STATE.triplet.includes(key) || STATE.revealed)
      ? `${key} = ${Math.round(val * 10) / 10} [${unit}]`
      : `${key} = ??? [${unit}]`;
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#22c55e';
    ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y0); ctx.stroke();
    ctx.strokeStyle = '#a855f7';
    ctx.beginPath(); ctx.moveTo(x1, y0); ctx.lineTo(x1, y1); ctx.stroke();
    ctx.strokeStyle = '#38bdf8';
    ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y1); ctx.stroke();
    const angleHyp = Math.atan2(y1 - y0, x1 - x0);
    const midHypX = x0 + (x1 - x0) * 0.5;
    const midHypY = y0 + (y1 - y0) * 0.5;
    const offset = 15;
    const textX = midHypX + offset * Math.sin(angleHyp);
    const textY = midHypY - offset * Math.cos(angleHyp);
    ctx.font = "bold 10px Segoe UI";
    ctx.fillStyle = '#22c55e';
    ctx.textAlign = "center"; ctx.textBaseline = "top";
    ctx.fillText(getMod(hKey, h, units[0]), x0 + (h * scale) / 2, y0 + 10);
    ctx.fillStyle = '#a855f7';
    ctx.textAlign = "left"; ctx.textBaseline = "middle";
    ctx.fillText(getMod(vKey, STATE.all[vKey], units[1]), x1 + 8, y0 - (v * scale) / 2);
    ctx.save();
    ctx.translate(textX, textY);
    ctx.rotate(angleHyp);
    ctx.fillStyle = '#38bdf8';
    ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText(getMod(hypKey, hyp, units[2]), 0, 0);
    ctx.restore();
  };
  drawTri('fresnelU', 'UR', 'UC', 'U', ['V', 'V', 'V']);
  drawTri('fresnelZ', 'R', 'XC', 'Z', ['Î©', 'Î©', 'Î©']);
  drawTri('fresnelS', 'P', 'Q', 'S', ['W', 'var', 'VA']);

  const scope = document.getElementById('scopeCanvas');
  const sCtx = scope.getContext('2d');
  const w = scope.width, h = scope.height, midY = h / 2;
  sCtx.clearRect(0, 0, w, h);
  const centerX = 100;
  const fresnelRadius = 60;
  const tangentX = centerX + fresnelRadius;
  const scopeWidth = w - tangentX - 40;
  const phiRad = rad(STATE.all.phi || 0);
  const freq = (2 * Math.PI * 2) / scopeWidth;

  const drawLatexArrow = (ctx, x1, y1, x2, y2, size = 10, color = null) => {
    const angle = Math.atan2(y2 - y1, x2 - x1);
    ctx.save();
    if (color) ctx.fillStyle = color; else ctx.fillStyle = ctx.strokeStyle;
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - size * Math.cos(angle - Math.PI / 8), y2 - size * Math.sin(angle - Math.PI / 8));
    ctx.lineTo(x2 - size * Math.cos(angle + Math.PI / 8), y2 - size * Math.sin(angle + Math.PI / 8));
    ctx.fill(); ctx.restore();
  };

  const drawVectorLabel = (ctx, x, y, text, color, position = "above") => {
    ctx.fillStyle = color;
    ctx.font = "italic bold 16px serif";
    const lx = x - 25;
    const ly = (position === "above") ? y - 12 : y + 25;
    ctx.fillText(text, lx, ly);
    ctx.lineWidth = 1;
    ctx.strokeStyle = color;
    ctx.beginPath(); ctx.moveTo(lx, ly - 15); ctx.lineTo(lx + 12, ly - 15); ctx.stroke();
    drawLatexArrow(ctx, lx, ly - 15, lx + 14, ly - 15, 5);
  };

  sCtx.strokeStyle = "#475569"; sCtx.fillStyle = "#475569"; sCtx.lineWidth = 1;
  sCtx.beginPath(); sCtx.moveTo(20, midY); sCtx.lineTo(w - 20, midY); sCtx.stroke();
  drawLatexArrow(sCtx, w - 30, midY, w - 15, midY);
  sCtx.font = "12px Arial"; sCtx.fillText("t [s]", w - 30, midY + 20);
  sCtx.beginPath(); sCtx.moveTo(centerX, h - 20); sCtx.lineTo(centerX, 20); sCtx.stroke();
  drawLatexArrow(sCtx, centerX, 30, centerX, 15);
  sCtx.lineWidth = 2;
  sCtx.beginPath(); sCtx.moveTo(tangentX, h - 20); sCtx.lineTo(tangentX, 20); sCtx.stroke();
  drawLatexArrow(sCtx, tangentX, 30, tangentX, 15);
  sCtx.fillText("u(t), i(t)", tangentX + 8, 25);
  sCtx.strokeStyle = "#334155"; sCtx.lineWidth = 1;
  sCtx.beginPath(); sCtx.arc(centerX, midY, fresnelRadius, 0, Math.PI * 2); sCtx.stroke();
  sCtx.strokeStyle = "#94a3b8";
  sCtx.beginPath();
  const startA = -Math.PI/2.2, endA = -Math.PI/1.6;
  sCtx.arc(centerX, midY, fresnelRadius + 18, startA, endA, true); sCtx.stroke();
  const ox = centerX + (fresnelRadius+18) * Math.cos(endA);
  const oy = midY + (fresnelRadius+18) * Math.sin(endA);
  drawLatexArrow(sCtx, ox + 5, oy - 2, ox, oy, 7);
  sCtx.font = "italic 16px serif"; sCtx.fillText("Ï‰", ox - 15, oy - 5);
  const uX = centerX + fresnelRadius;
  sCtx.strokeStyle = "#38bdf8"; sCtx.lineWidth = 3;
  sCtx.beginPath(); sCtx.moveTo(centerX, midY); sCtx.lineTo(uX, midY); sCtx.stroke();
  drawLatexArrow(sCtx, centerX, midY, uX, midY, 10, "#38bdf8");
  drawVectorLabel(sCtx, uX, midY, "U", "#38bdf8", "above");
  const iX = centerX + Math.cos(-phiRad) * (fresnelRadius * 0.7);
  const iY = midY - Math.sin(-phiRad) * (fresnelRadius * 0.7);
  sCtx.strokeStyle = "#f472b6"; sCtx.lineWidth = 3;
  sCtx.beginPath(); sCtx.moveTo(centerX, midY); sCtx.lineTo(iX, iY); sCtx.stroke();
  drawLatexArrow(sCtx, centerX, midY, iX, iY, 10, "#f472b6");
  drawVectorLabel(sCtx, iX, iY, "I", "#f472b6", "below");
  sCtx.strokeStyle = "#a855f7"; sCtx.lineWidth = 1.5;
  sCtx.beginPath(); sCtx.arc(centerX, midY, 35, 0, -phiRad, phiRad > 0); sCtx.stroke();
  sCtx.fillStyle = "#a855f7"; sCtx.font = "italic bold 24px serif";
  sCtx.fillText("Ï†", centerX + 45 * Math.cos(-phiRad/2), midY - 45 * Math.sin(-phiRad/2));

  const drawSignal = (color, amp, phase) => {
    sCtx.beginPath(); sCtx.strokeStyle = color; sCtx.lineWidth = 2;
    for (let x = 0; x <= scopeWidth; x++) {
      const y = midY - Math.sin(x * freq - phase) * amp;
      x === 0 ? sCtx.moveTo(tangentX + x, y) : sCtx.lineTo(tangentX + x, y);
    }
    sCtx.stroke();
  };
  drawSignal("#38bdf8", fresnelRadius, 0);
  drawSignal("#f472b6", fresnelRadius * 0.7, phiRad);
  const zeroU = Math.PI / freq;
  const zeroI = (Math.PI + phiRad) / freq;
  const yBase = midY + 40;
  sCtx.strokeStyle = "#a855f7"; sCtx.setLineDash([4, 2]);
  sCtx.beginPath();
  sCtx.moveTo(tangentX + zeroU, midY); sCtx.lineTo(tangentX + zeroU, yBase + 10);
  sCtx.moveTo(tangentX + zeroI, midY); sCtx.lineTo(tangentX + zeroI, yBase + 10);
  sCtx.stroke();
  sCtx.setLineDash([]);
  sCtx.lineWidth = 1.5;
  sCtx.beginPath(); sCtx.moveTo(tangentX + zeroU, yBase); sCtx.lineTo(tangentX + zeroI, yBase); sCtx.stroke();
  drawLatexArrow(sCtx, tangentX + zeroI - 5, yBase, tangentX + zeroI, yBase, 6);
  drawLatexArrow(sCtx, tangentX + zeroU + 5, yBase, tangentX + zeroU, yBase, 6);
  sCtx.font = "italic bold 20px serif";
  sCtx.fillText("Ï†", tangentX + (zeroU + zeroI)/2 - 8, yBase + 22);
}

window.onload = generateExercise;
</script>
</body>
</html>