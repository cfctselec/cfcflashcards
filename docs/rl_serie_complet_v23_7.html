<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RL Master presQPro v12.7 ‚Äî Omniscience Dynamique</title>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$']]
            },
            options: {
                enableMenu: false
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                }
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        :root {
            --bg: #0f172a; --card: #1e293b; --accent: #38bdf8;
            --text: #f1f5f9; --muted: #94a3b8; --success: #22c55e;
            --warn: #f43f5e; --induct: #f59e0b; --current: #f472b6;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); padding: 15px; line-height: 1.4; }
        .container { max-width: 1200px; margin: 0 auto; }
        
        header { 
            display: flex; align-items: center; justify-content: space-between;
            background: var(--card); padding: 15px 20px; border-radius: 12px; 
            border: 1px solid #334155; margin-bottom: 20px;
        }

        .actions { display: flex; gap: 10px; margin-bottom: 20px; }
        button { 
            flex: 1; padding: 12px; border-radius: 8px; border: none; 
            cursor: pointer; font-weight: 700; transition: 0.3s; 
            text-transform: uppercase;
        }
        .btn-gen { background: var(--accent); color: #0f172a; }
        .btn-solve { background: var(--success); color: #0f172a; }
        button:hover { opacity: 0.9; transform: translateY(-1px); }

        .grid { 
            display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); 
            gap: 12px; margin-bottom: 25px; 
        }
        .input-group { 
            background: var(--card); padding: 10px 14px; border-radius: 10px; 
            border: 1px solid #334155; position: relative;
        }
        .input-group.given { border-color: var(--accent); border-width: 2px; }
        .input-group label { display: block; font-size: 0.75rem; color: var(--muted); margin-bottom: 4px; }
        .input-group input { width: 100%; background: transparent; border: none; color: white; font-size: 1.1rem; font-weight: 700; outline: none; }

        .hidden-ans { filter: blur(8px); pointer-events: none; user-select: none; color: #94a3b8 !important; }
        .revealed { color: var(--success) !important; filter: none !important; text-shadow: 0 0 10px rgba(34, 197, 94, 0.2); }
        .unit { position: absolute; right: 10px; bottom: 10px; font-size: 0.7rem; color: var(--muted); font-style: italic; }

        .visual-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 15px; }
        .canvas-box { background: #0b1324; border-radius: 15px; padding: 15px; border: 1px solid #334155; text-align: center; }
        .canvas-box.full-width { grid-column: 1 / -1; }
        canvas { width: 100%; height: auto; border-radius: 8px; }
        h3 { font-size: 0.8rem; margin-bottom: 10px; color: var(--accent); text-transform: uppercase; }
        
        .legend { display: flex; justify-content: center; gap: 15px; font-size: 0.8rem; margin-top: 5px; }
        .dot-u { width: 8px; height: 8px; background: var(--accent); border-radius: 50%; }
        .dot-i { width: 8px; height: 8px; background: var(--current); border-radius: 50%; }
        .info-bar { background: #1a2b4e; padding: 8px 15px; border-radius: 8px; margin-bottom: 20px; font-size: 0.85rem; color: var(--accent); border-left: 4px solid var(--accent); }

        #solutionMethod {
            margin-top: 30px; background: #1e293b; padding: 25px;
            border-radius: 12px; border: 2px solid var(--success);
            display: none; margin-bottom: 30px;
        }
        .method-step { 
            margin-bottom: 12px; display: flex; align-items: flex-start; gap: 10px; 
            background: rgba(255,255,255,0.03); padding: 15px; border-radius: 10px; border-left: 4px solid var(--success);
        }
        .step-num { background: var(--success); color: #0f172a; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; }
        
        #hintBox {
            background: #2d3748; border-left: 4px solid var(--induct); 
            padding: 15px; margin-bottom: 20px; border-radius: 8px; display: none;
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <div>
            <h1 style="font-size: 1.4rem;">RL Master <span style="color: var(--accent);">Pro</span> v12.7</h1>
            <p style="font-size: 0.85rem; color: var(--muted);">R√©solveur Universel RL S√©rie (par OM 2026.01.01)</p>
        </div>
    </header>

    <div id="currentTriplet" class="info-bar">
        Donn√©es d'entr√©e (al√©atoires) : <span id="tripletDisplay">-</span>
    </div>

    <div class="actions">
        <button class="btn-gen" onclick="generateExercise()">G√©n√©rer Nouveau Cas</button>
        <button id="btn-hint" style="background: var(--induct); color: #0f172a;" onclick="showHint()">Indice de r√©solution</button>
        <button class="btn-solve" onclick="revealAnswers()">V√©rifier / R√©v√©ler</button>
    </div>

    <div id="hintBox">
        <h3 style="color: var(--induct); margin-top: 0;">üí° Strat√©gie sugg√©r√©e</h3>
        <div id="hintText" style="font-size: 0.95rem;"></div>
    </div>

    <div class="grid" id="inputGrid"></div>

    <div id="solutionMethod">
        <h2 style="color: var(--success); margin-bottom: 10px; font-size: 1.4rem; border-bottom: 1px solid var(--success); padding-bottom: 10px;">
            üìö Guide de R√©solution D√©taill√©
        </h2>
        <div id="stepsList"></div>
    </div>

    <div class="visual-grid">
        <div class="canvas-box"><h3>Tensions [V]</h3><canvas id="fresnelU" width="300" height="220"></canvas></div>
        <div class="canvas-box"><h3>Imp√©dances [Œ©]</h3><canvas id="fresnelZ" width="300" height="220"></canvas></div>
        <div class="canvas-box"><h3>Puissances</h3><canvas id="fresnelS" width="300" height="220"></canvas></div>
        <div class="canvas-box full-width">
            <h3>Oscilloscope : u(t) & i(t)</h3>
            <canvas id="scopeCanvas" width="900" height="300"></canvas>
            <div class="legend">
                <span><div class="dot-u"></div> u(t)</span>
                <span><div class="dot-i"></div> i(t)</span>
                <span id="periodDisplay" style="color: var(--muted); margin-left: 20px;">T = ...</span>
            </div>
        </div>
    </div>
</div>

<script>
    const ALL_KEYS = [
        {id:"f", label:"Fr√©quence", unit:"Hz"}, {id:"L", label:"Inductance L", unit:"H"},
        {id:"U", label:"Tension Source U", unit:"V"}, {id:"I", label:"Courant I", unit:"A"}, 
        {id:"R", label:"R√©sistance R", unit:"Œ©"}, {id:"XL", label:"R√©actance XL", unit:"Œ©"}, 
        {id:"Z", label:"Imp√©dance Z", unit:"Œ©"}, {id:"UR", label:"Tension UR", unit:"V"}, 
        {id:"UL", label:"Tension UL", unit:"V"}, {id:"P", label:"Puissance P", unit:"W"}, 
        {id:"Q", label:"Puissance Q", unit:"var"}, {id:"S", label:"Puissance S", unit:"VA"}, 
        {id:"cos_phi", label:"cos œÜ", unit:"-"}, {id:"phi", label:"D√©phasage œÜ", unit:"¬∞"}
    ];

    const VARIABLE_BANKS = ["f", "L", "U", "I", "R", "XL", "Z", "UR", "UL", "P", "Q", "S", "cos_phi", "phi"];
    let STATE = { all: {}, triplet: [], revealed: false };

    const rad = (d) => d * Math.PI / 180;
    const deg = (r) => r * 180 / Math.PI;

    function computeAll(K) {
        let o = { ...K };
        for(let i=0; i<15; i++) {
            if (o.f && o.L) o.XL = 2 * Math.PI * o.f * o.L;
            if (o.XL && o.f && o.f > 0) o.L = o.XL / (2 * Math.PI * o.f);
            if (o.R && o.XL) { o.Z = Math.sqrt(o.R**2 + o.XL**2); o.phi = deg(Math.atan2(o.XL, o.R)); o.cos_phi = o.R / o.Z; }
            if (o.Z && o.cos_phi) { o.R = o.Z * o.cos_phi; o.XL = Math.sqrt(Math.max(0, o.Z**2 - o.R**2)); o.phi = deg(Math.acos(o.cos_phi)); }
            if (o.I && o.Z) o.U = o.I * o.Z;
            if (o.U && o.Z) o.I = o.U / o.Z;
            if (o.U && o.I) o.Z = o.U / o.I;
            if (o.I && o.R) o.UR = o.I * o.R;
            if (o.I && o.XL) o.UL = o.I * o.XL;
            if (o.UR && o.UL) { o.U = Math.sqrt(o.UR**2 + o.UL**2); o.phi = deg(Math.atan2(o.UL, o.UR)); o.cos_phi = o.UR/o.U;}
            if (o.P && o.Q) { o.S = Math.sqrt(o.P**2 + o.Q**2); o.cos_phi = o.P / o.S; o.phi = deg(Math.acos(o.cos_phi)); }
            if (o.U && o.I) o.S = o.U * o.I;
            if (o.R && o.I) o.P = o.R * (o.I**2);
            if (o.XL && o.I) o.Q = o.XL * (o.I**2);
        }
        return o;
    }

    function generateExercise() {
        document.getElementById('solutionMethod').style.display = 'none';
        document.getElementById('hintBox').style.display = 'none';
        
        let success = false;
        while (!success) {
            let triplet = [];
            let pool = [...VARIABLE_BANKS];
            for(let i=0; i<4; i++) {
                let idx = Math.floor(Math.random() * pool.length);
                triplet.push(pool.splice(idx, 1)[0]);
            }
            const seed = { f: 50, L: 0.1 + Math.random()*0.3, U: 230, R: 40 + Math.random()*60 };
            const fullRef = computeAll(seed);
            let testKnown = {};
            triplet.forEach(k => testKnown[k] = fullRef[k]);
            const result = computeAll(testKnown);
            if (ALL_KEYS.every(k => result[k.id] !== undefined && !isNaN(result[k.id]))) {
                STATE.all = result; STATE.triplet = triplet; STATE.revealed = false; success = true;
            }
        }
        document.getElementById('tripletDisplay').textContent = STATE.triplet.join(' | ');
        updateUI();
    }

    function updateUI() {
        const grid = document.getElementById('inputGrid');
        grid.innerHTML = ALL_KEYS.map(k => {
            const isKnown = STATE.triplet.includes(k.id);
            const val = k.id === "L" ? (STATE.all[k.id]).toFixed(4) : Math.round(STATE.all[k.id]*100)/100;
            return `
                <div class="input-group ${isKnown ? 'given' : ''}">
                    <label>${k.label}</label>
                    <input type="text" value="${val}" class="${!isKnown && !STATE.revealed ? 'hidden-ans' : (STATE.revealed && !isKnown ? 'revealed' : '')}" readonly>
                    <span class="unit">${k.unit}</span>
                </div>`;
        }).join('');
        document.getElementById('periodDisplay').textContent = `T = ${(1000/STATE.all.f).toFixed(1)}ms`;
        drawVisuals();
    }

    function showHint() {
        const hintBox = document.getElementById('hintBox');
        const hintText = document.getElementById('hintText');
        hintBox.style.display = 'block';
        let hints = [];
        const k = STATE.triplet;

        if (k.includes('f') && k.includes('L')) hints.push("üí° Utilisez $f$ et $L$ pour calculer la r√©actance $X_L$.");
        if (k.includes('R') && k.includes('XL')) hints.push("üí° Avec $R$ et $X_L$, vous pouvez trouver l'imp√©dance totale $Z$ (Pythagore).");
        if (k.includes('U') && k.includes('Z')) hints.push("üí° La loi d'Ohm $I = U/Z$ vous donnera l'intensit√©.");
        
        hintText.innerHTML = hints.length > 0 ? hints.join("<br>") : "Analysez les relations entre les tensions ou les puissances pour d√©bloquer une variable.";
        if (window.MathJax) MathJax.typesetPromise([hintText]);
    }

function revealAnswers() {
    STATE.revealed = true;
    updateUI();
    const solDiv = document.getElementById('solutionMethod');
    const stepsList = document.getElementById('stepsList');
    solDiv.style.display = 'block';
    
    let html = "";
    let known = [...STATE.triplet]; // Ex: ["U", "P", "cos_phi"]
    let stepIdx = 1;

    // Base de connaissance compl√®te pour circuit RL s√©rie
    const logic = [
        // --- Imp√©dance et Composants ---
        { req: ['f', 'L'], res: 'XL', t: "R√©actance inductive", f: "X_L = 2\\pi f L \\,[\\Omega]" },
        { req: ['R', 'XL'], res: 'Z', t: "Imp√©dance totale", f: "Z = \\sqrt{R^2 + X_L^2}\\,[\\Omega]" },
        { req: ['Z', 'R'], res: 'XL', t: "R√©actance inductive", f: "X_L = \\sqrt{Z^2 - R^2}\\,[\\Omega]" },
        { req: ['Z', 'XL'], res: 'R', t: "R√©sistance", f: "R = \\sqrt{Z^2 - X_L^2}\\,[\\Omega]" },

        // --- Loi d'Ohm ---
        { req: ['U', 'Z'], res: 'I', t: "Courant efficace", f: "I = \\frac{U}{Z}\\,[A]" },
        { req: ['U', 'I'], res: 'Z', t: "Imp√©dance totale", f: "Z = \\frac{U}{I}\\,[\\Omega]" },
        { req: ['I', 'Z'], res: 'U', t: "Tension totale", f: "U = Z \\cdot I\\,[V]" },
        { req: ['I', 'R'], res: 'UR', t: "Tension aux bornes de R", f: "U_R = I \\cdot R\\,[V]" },
        { req: ['I', 'XL'], res: 'UL', t: "Tension aux bornes de L", f: "U_L = I \\cdot X_L\\,[V]" },
        { req: ['U', 'UR'], res: 'UL', t: "Tension aux bornes de L", f: "U_L = \\sqrt{U^2 - U_R^2}\\,[V]" },
        { req: ['U', 'UL'], res: 'UR', t: "Tension aux bornes de R", f: "U_R = \\sqrt{U^2 - U_L^2}\\,[V]" },
        { req: ['UR', 'UL'], res: 'U', t: "Tension totale", f: "U = \\sqrt{U_R^2 + U_L^2}\\,[V]" },

        // --- Trigonom√©trie (phi et cos phi) ---
        { req: ['R', 'Z'], res: 'cos_phi', t: "Facteur de puissance", f: "\\cos(\\varphi) = \\frac{R}{Z}" },
        { req: ['Z', 'cos_phi'], res: 'R', t: "R√©sistance", f: "R = Z \\cdot \\cos(\\varphi)\\,[\\Omega]" },
        { req: ['cos_phi'], res: 'phi', t: "D√©phasage", f: "\\varphi = \\arccos(\\cos \\varphi)\\,[^o]" },
        { req: ['phi'], res: 'cos_phi', t: "Facteur de puissance", f: "\\cos \\varphi = \\cos(\\varphi)" },
        { req: ['R', 'XL'], res: 'phi', t: "D√©phasage", f: "\\varphi = \\arctan\\left(\\frac{X_L}{R}\\right)\\,[^o]" },
        { req: ['UR', 'U'], res: 'cos_phi', t: "Facteur de puissance", f: "\\cos(\\varphi) = \\frac{U_R}{U}" },

        // --- Puissances ---
        { req: ['U', 'I', 'cos_phi'], res: 'P', t: "Puissance active", f: "P = U \\cdot I \\cdot \\cos(\\varphi)\\,[W]" },
        { req: ['P', 'Q'], res: 'S', t: "Puissance apparente", f: "S = \\sqrt{P^2 + Q^2}\\,[V\\!\\!A]" },
        { req: ['U', 'I'], res: 'S', t: "Puissance apparente", f: "S = U \\cdot I\\,[V\\!\\!A]" },
        { req: ['S', 'cos_phi'], res: 'P', t: "Puissance active", f: "P = S \\cdot \\cos(\\varphi)\\,[W]" },
        { req: ['P', 'cos_phi'], res: 'S', t: "Puissance apparente", f: "S = \\frac{P}{\\cos \\varphi}\\,[V\\!\\!A]" },
        { req: ['P', 'I'], res: 'R', t: "R√©sistance (via P)", f: "R = \\frac{P}{I^2}\\,[\\Omega]" },
        { req: ['Q', 'I'], res: 'XL', t: "R√©actance (via Q)", f: "X_L = \\frac{Q}{I^2}\\,[\\Omega]" }
    ];

    let added = true;
    while(added) {
        added = false;
        logic.forEach(s => {
            // Si le r√©sultat n'est pas encore connu MAIS que tous les pr√©requis le sont
            if(!known.includes(s.res) && s.req.every(r => known.includes(r))) {
                html += `
                    <div class="method-step">
                        <div class="step-num">${stepIdx++}</div>
                        <div style="flex:1">
                            <b style="color: #64ffda;">${s.t} :</b>
                            <div style="background: #111b2d; padding: 12px; margin: 8px 0; border-radius: 8px; border-left: 3px solid #64ffda; color: #e6f1ff; font-size: 1.1em;">
                                $$ ${s.f} $$
                            </div>
                        </div>
                    </div>`;
                known.push(s.res);
                added = true;
            }
        });
    }

    stepsList.innerHTML = html || "<p>Calcul direct effectu√©.</p>";
    
    // D√©clenchement du rendu MathJax
    if (window.MathJax) {
        MathJax.typesetPromise([stepsList]).catch((err) => console.log(err));
    }
    
    solDiv.scrollIntoView({ behavior: 'smooth' });
}

function drawVisuals() {
    const drawTri = (id, hKey, vKey, hypKey, units) => {
        const canvas = document.getElementById(id);
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, 300, 220);

        const h = STATE.all[hKey], v = STATE.all[vKey], hyp = STATE.all[hypKey];
        // Calcul du scale pour que le triangle tienne bien dans le canvas
        const scale = 110 / Math.max(h, v, hyp || 1);
        const x0 = 45, y0 = 175, x1 = x0 + h * scale, y1 = y0 - v * scale;

        // Dessin des segments
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#22c55e'; ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y0); ctx.stroke(); // Base
        ctx.strokeStyle = '#f59e0b'; ctx.beginPath(); ctx.moveTo(x1, y0); ctx.lineTo(x1, y1); ctx.stroke(); // Hauteur
        ctx.strokeStyle = '#38bdf8'; ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x1, y1); ctx.stroke(); // Hypot√©nuse

        // Style du texte
        ctx.fillStyle = "white"; 
        ctx.font = "bold 10px Segoe UI"; 
        
        // Fonction interne pour g√©rer l'affichage masqu√© ou r√©v√©l√©
        const getMod = (key, val, unit) => (STATE.triplet.includes(key) || STATE.revealed) 
            ? `${key} = ${Math.round(val * 10) / 10} [${unit}]` 
            : `${key} = ??? [${unit}]`;

        // Affichage des labels
        ctx.textAlign = "center";
        ctx.fillText(getMod(hKey, h, units[0]), x0 + (h * scale) / 2, y0 + 20); // Horizontal
        
        ctx.textAlign = "left";
        ctx.fillText(getMod(vKey, v, units[1]), x1 + 10, y0 - (v * scale) / 2); // Vertical
        
        ctx.textAlign = "center";
        ctx.fillText(getMod(hypKey, hyp, units[2]), x0 + (h * scale) / 3, y1 - 12); // Hypot√©nuse
    };

    // Appels pour les 3 triangles avec leurs unit√©s respectives
    drawTri('fresnelU', 'UR', 'UL', 'U', ['V', 'V', 'V']);
    drawTri('fresnelZ', 'R', 'XL', 'Z', ['Œ©', 'Œ©', 'Œ©']);
    drawTri('fresnelS', 'P', 'Q', 'S', ['W', 'var', 'VA']);

    // --- Partie Oscilloscope & Fresnel ---
    const scope = document.getElementById('scopeCanvas');
    const sCtx = scope.getContext('2d');
    const w = scope.width, h = scope.height, midY = h / 2;

    sCtx.clearRect(0, 0, w, h);

    // Configuration G√©om√©trique
    const centerX = 100; 
    const fresnelRadius = 60; 
    const tangentX = centerX + fresnelRadius; // Point t=0
    const scopeWidth = w - tangentX - 40;
    const phiRad = rad(STATE.all.phi || 0);
    const freq = (2 * Math.PI * 2) / scopeWidth; // 2 p√©riodes

    // --- 1. FONCTIONS UTILITAIRES POUR FL√àCHES ET LABELS ---
    const drawLatexArrow = (ctx, x1, y1, x2, y2, size = 10, color = null) => {
        const angle = Math.atan2(y2 - y1, x2 - x1);
        
        // Sauvegarder l'√©tat du contexte
        ctx.save();
        
        // Appliquer la couleur si fournie, sinon utiliser la couleur de trait actuelle
        if (color) {
            ctx.fillStyle = color;
        } else {
            ctx.fillStyle = ctx.strokeStyle; // h√©rite de la couleur du trait
        }
        
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - size * Math.cos(angle - Math.PI / 8), y2 - size * Math.sin(angle - Math.PI / 8));
        ctx.lineTo(x2 - size * Math.cos(angle + Math.PI / 8), y2 - size * Math.sin(angle + Math.PI / 8));
        ctx.fill();
        
        // Restaurer l'√©tat du contexte
        ctx.restore();
    };

    const drawVectorLabel = (ctx, x, y, text, color, position = "above") => {
        ctx.fillStyle = color;
        ctx.font = "italic bold 16px serif";
        
        // Ajustement position : I en dessous, U au dessus
        const lx = x - 25; 
        const ly = (position === "above") ? y - 12 : y + 25;
        
        ctx.fillText(text, lx, ly);
        
        // Fl√®che vectorielle sur la lettre (statique)
        ctx.lineWidth = 1;
        ctx.strokeStyle = color;
        ctx.beginPath();
        ctx.moveTo(lx, ly - 15); ctx.lineTo(lx + 12, ly - 15);
        ctx.stroke();
        drawLatexArrow(ctx, lx, ly - 15, lx + 14, ly - 15, 5);
    };

    // --- 2. DESSIN DES AXES ---
    sCtx.strokeStyle = "#475569";
    sCtx.fillStyle = "#475569";
    sCtx.lineWidth = 1;

    // Axe Horizontal (t)
    sCtx.beginPath(); sCtx.moveTo(20, midY); sCtx.lineTo(w - 20, midY); sCtx.stroke();
    drawLatexArrow(sCtx, w - 30, midY, w - 15, midY);
    sCtx.font = "12px Arial";
    sCtx.fillText("t [s]", w - 30, midY + 20);

    // Axe Vertical Central (Cercle) avec fl√®che vers le haut
    sCtx.beginPath(); sCtx.moveTo(centerX, h - 20); sCtx.lineTo(centerX, 20); sCtx.stroke();
    drawLatexArrow(sCtx, centerX, 30, centerX, 15);

    // Axe Vertical Tangent (t=0) avec fl√®che et labels
    sCtx.lineWidth = 2;
    sCtx.beginPath(); sCtx.moveTo(tangentX, h - 20); sCtx.lineTo(tangentX, 20); sCtx.stroke();
    drawLatexArrow(sCtx, tangentX, 30, tangentX, 15);
    sCtx.fillText("u(t), i(t)", tangentX + 8, 25);

    // --- 3. DIAGRAMME DE FRESNEL ---
    sCtx.strokeStyle = "#334155";
    sCtx.lineWidth = 1;
    sCtx.beginPath(); sCtx.arc(centerX, midY, fresnelRadius, 0, Math.PI * 2); sCtx.stroke();

    // Nouveau trac√© du Sens Trigonom√©trique œâ (arc avec fl√®che nette)
    sCtx.strokeStyle = "#94a3b8";
    sCtx.beginPath();
    const startA = -Math.PI/2.2, endA = -Math.PI/1.6;
    sCtx.arc(centerX, midY, fresnelRadius + 18, startA, endA, true);
    sCtx.stroke();
    // Fl√®che au bout de l'arc omega
    const ox = centerX + (fresnelRadius+18) * Math.cos(endA);
    const oy = midY + (fresnelRadius+18) * Math.sin(endA);
    drawLatexArrow(sCtx, ox + 5, oy - 2, ox, oy, 7);
    sCtx.font = "italic 16px serif";
    sCtx.fillText("œâ", ox - 15, oy - 5);

    // Vecteur U (R√©f√©rence √† 0¬∞)
    const uX = centerX + fresnelRadius;
    sCtx.strokeStyle = "#38bdf8";
    sCtx.lineWidth = 3;
    sCtx.beginPath(); sCtx.moveTo(centerX, midY); sCtx.lineTo(uX, midY); sCtx.stroke();
    drawLatexArrow(sCtx, centerX, midY, uX, midY, 10, "#38bdf8");
    drawVectorLabel(sCtx, uX, midY, "U", "#38bdf8", "above");

    // Vecteur I (D√©phas√©)
    const iX = centerX + Math.cos(-phiRad) * (fresnelRadius * 0.7);
    const iY = midY - Math.sin(-phiRad) * (fresnelRadius * 0.7);
    sCtx.strokeStyle = "#f472b6";
    sCtx.lineWidth = 3;
    sCtx.beginPath(); sCtx.moveTo(centerX, midY); sCtx.lineTo(iX, iY); sCtx.stroke();
    drawLatexArrow(sCtx, centerX, midY, iX, iY, 10, "#f472b6");    
    // I est plac√© en dessous de sa fl√®che comme demand√©
    drawVectorLabel(sCtx, iX, iY, "I", "#f472b6", "below");

    // Variable varphi (Grand format, Italique)
    sCtx.strokeStyle = "#f59e0b";
    sCtx.lineWidth = 1.5;
    sCtx.beginPath();
    sCtx.arc(centerX, midY, 35, 0, phiRad, phiRad < 0);
    sCtx.stroke();
    sCtx.fillStyle = "#f59e0b";
    sCtx.font = "italic bold 24px serif"; 
    sCtx.fillText("œÜ", centerX + 45 * Math.cos(-phiRad/2), midY - 45 * Math.sin(-phiRad/2));

    // --- 4. SIGNAUX ET PHI SUR AXE HORIZONTAL ---
    const drawSignal = (color, amp, phase) => {
        sCtx.beginPath();
        sCtx.strokeStyle = color;
        sCtx.lineWidth = 2;
        for (let x = 0; x <= scopeWidth; x++) {
            const y = midY - Math.sin(x * freq - phase) * amp;
            x === 0 ? sCtx.moveTo(tangentX + x, y) : sCtx.lineTo(tangentX + x, y);
        }
        sCtx.stroke();
    };

    drawSignal("#38bdf8", fresnelRadius, 0); 
    drawSignal("#f472b6", fresnelRadius * 0.7, phiRad);

    // D√©phasage œÜ sous l'axe au passage par z√©ro
    const zeroU = Math.PI / freq; 
    const zeroI = (Math.PI + phiRad) / freq; 
    const yBase = midY + 40;

    sCtx.strokeStyle = "#f59e0b";
    sCtx.setLineDash([4, 2]);
    sCtx.beginPath();
    sCtx.moveTo(tangentX + zeroU, midY); sCtx.lineTo(tangentX + zeroU, yBase + 10);
    sCtx.moveTo(tangentX + zeroI, midY); sCtx.lineTo(tangentX + zeroI, yBase + 10);
    sCtx.stroke();
    sCtx.setLineDash([]);

    // Fl√®che œÜ double sens sous l'axe
    sCtx.lineWidth = 1.5;
    sCtx.beginPath();
    sCtx.moveTo(tangentX + zeroU, yBase); sCtx.lineTo(tangentX + zeroI, yBase);
    sCtx.stroke();
    drawLatexArrow(sCtx, tangentX + zeroI - 5, yBase, tangentX + zeroI, yBase, 6);
    drawLatexArrow(sCtx, tangentX + zeroU + 5, yBase, tangentX + zeroU, yBase, 6);
    sCtx.font = "italic bold 20px serif";
    sCtx.fillText("œÜ", tangentX + (zeroU + zeroI)/2 - 8, yBase + 22);
    }
    window.onload = generateExercise;
</script>
</body>
</html>